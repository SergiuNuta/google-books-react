{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst url_1 = require(\"url\");\n\nconst logging_1 = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst resolver_dns_1 = require(\"./resolver-dns\");\n\nconst http = require(\"http\");\n\nconst logging = require(\"./logging\");\n\nconst subchannel_1 = require(\"./subchannel\");\n\nconst TRACER_NAME = 'proxy';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nfunction getProxyInfo() {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n\n  let proxyUrl;\n\n  try {\n    proxyUrl = new url_1.URL(proxyEnv);\n  } catch (e) {\n    logging_1.log(constants_1.LogVerbosity.INFO, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n\n  if (proxyUrl.protocol !== 'http') {\n    logging_1.log(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n    return {};\n  }\n\n  let userCred = null;\n\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      logging_1.log(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n\n  const result = {\n    address: proxyUrl.host\n  };\n\n  if (userCred) {\n    result.creds = userCred;\n  }\n\n  trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n  return result;\n}\n\nconst PROXY_INFO = getProxyInfo();\n\nfunction getNoProxyHostList() {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\n\nconst NO_PROXY_HOSTS = getNoProxyHostList();\n\nfunction shouldUseProxy(target) {\n  if (!PROXY_INFO.address) {\n    return false;\n  }\n\n  let serverHost;\n  const parsedTarget = resolver_dns_1.parseTarget(target);\n\n  if (parsedTarget) {\n    serverHost = parsedTarget.host;\n  } else {\n    return false;\n  }\n\n  for (const host of NO_PROXY_HOSTS) {\n    if (host === serverHost) {\n      trace('Not using proxy for target in no_proxy list: ' + target);\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.shouldUseProxy = shouldUseProxy;\n\nfunction getProxiedConnection(target, subchannelAddress) {\n  if (!(PROXY_INFO.address && shouldUseProxy(target) && subchannel_1.isTcpSubchannelAddress(subchannelAddress))) {\n    return Promise.reject();\n  }\n\n  const subchannelAddressPathString = `${subchannelAddress.host}:${subchannelAddress.port}`;\n  trace('Using proxy ' + PROXY_INFO.address + ' to connect to ' + target + ' at ' + subchannelAddress);\n  const options = {\n    method: 'CONNECT',\n    host: PROXY_INFO.address,\n    path: subchannelAddressPathString\n  };\n\n  if (PROXY_INFO.creds) {\n    options.headers = {\n      'Proxy-Authorization': 'Basic ' + Buffer.from(PROXY_INFO.creds).toString('base64')\n    };\n  }\n\n  return new Promise((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      request.removeAllListeners();\n      socket.removeAllListeners();\n\n      if (res.statusCode === http.STATUS_CODES.OK) {\n        trace('Successfully connected to ' + subchannelAddress + ' through proxy ' + PROXY_INFO.address);\n        resolve(socket);\n      } else {\n        trace('Failed to connect to ' + subchannelAddress + ' through proxy ' + PROXY_INFO.address);\n        reject();\n      }\n    });\n    request.once('error', err => {\n      request.removeAllListeners();\n      trace('Failed to connect to proxy ' + PROXY_INFO.address);\n      reject();\n    });\n  });\n}\n\nexports.getProxiedConnection = getProxiedConnection;","map":{"version":3,"sources":["../../src/http_proxy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst url_1 = require(\"url\");\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst resolver_dns_1 = require(\"./resolver-dns\");\nconst http = require(\"http\");\nconst logging = require(\"./logging\");\nconst subchannel_1 = require(\"./subchannel\");\nconst TRACER_NAME = 'proxy';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n    let proxyEnv = '';\n    let envVar = '';\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n     * fallback behavior can be removed if there's a demand for it.\n     */\n    if (process.env.grpc_proxy) {\n        envVar = 'grpc_proxy';\n        proxyEnv = process.env.grpc_proxy;\n    }\n    else if (process.env.https_proxy) {\n        envVar = 'https_proxy';\n        proxyEnv = process.env.https_proxy;\n    }\n    else if (process.env.http_proxy) {\n        envVar = 'http_proxy';\n        proxyEnv = process.env.http_proxy;\n    }\n    else {\n        return {};\n    }\n    let proxyUrl;\n    try {\n        proxyUrl = new url_1.URL(proxyEnv);\n    }\n    catch (e) {\n        logging_1.log(constants_1.LogVerbosity.INFO, `cannot parse value of \"${envVar}\" env var`);\n        return {};\n    }\n    if (proxyUrl.protocol !== 'http') {\n        logging_1.log(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n        return {};\n    }\n    let userCred = null;\n    if (proxyUrl.username) {\n        if (proxyUrl.password) {\n            logging_1.log(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n            userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n        }\n        else {\n            userCred = proxyUrl.username;\n        }\n    }\n    const result = {\n        address: proxyUrl.host\n    };\n    if (userCred) {\n        result.creds = userCred;\n    }\n    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n    return result;\n}\nconst PROXY_INFO = getProxyInfo();\nfunction getNoProxyHostList() {\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n    let noProxyStr = process.env.no_grpc_proxy;\n    let envVar = 'no_grpc_proxy';\n    if (!noProxyStr) {\n        noProxyStr = process.env.no_proxy;\n        envVar = 'no_proxy';\n    }\n    if (noProxyStr) {\n        trace('No proxy server list set by environment variable ' + envVar);\n        return noProxyStr.split(',');\n    }\n    else {\n        return [];\n    }\n}\nconst NO_PROXY_HOSTS = getNoProxyHostList();\nfunction shouldUseProxy(target) {\n    if (!PROXY_INFO.address) {\n        return false;\n    }\n    let serverHost;\n    const parsedTarget = resolver_dns_1.parseTarget(target);\n    if (parsedTarget) {\n        serverHost = parsedTarget.host;\n    }\n    else {\n        return false;\n    }\n    for (const host of NO_PROXY_HOSTS) {\n        if (host === serverHost) {\n            trace('Not using proxy for target in no_proxy list: ' + target);\n            return false;\n        }\n    }\n    return true;\n}\nexports.shouldUseProxy = shouldUseProxy;\nfunction getProxiedConnection(target, subchannelAddress) {\n    if (!(PROXY_INFO.address && shouldUseProxy(target) && subchannel_1.isTcpSubchannelAddress(subchannelAddress))) {\n        return Promise.reject();\n    }\n    const subchannelAddressPathString = `${subchannelAddress.host}:${subchannelAddress.port}`;\n    trace('Using proxy ' + PROXY_INFO.address + ' to connect to ' + target + ' at ' + subchannelAddress);\n    const options = {\n        method: 'CONNECT',\n        host: PROXY_INFO.address,\n        path: subchannelAddressPathString\n    };\n    if (PROXY_INFO.creds) {\n        options.headers = {\n            'Proxy-Authorization': 'Basic ' + Buffer.from(PROXY_INFO.creds).toString('base64')\n        };\n    }\n    return new Promise((resolve, reject) => {\n        const request = http.request(options);\n        request.once('connect', (res, socket, head) => {\n            request.removeAllListeners();\n            socket.removeAllListeners();\n            if (res.statusCode === http.STATUS_CODES.OK) {\n                trace('Successfully connected to ' + subchannelAddress + ' through proxy ' + PROXY_INFO.address);\n                resolve(socket);\n            }\n            else {\n                trace('Failed to connect to ' + subchannelAddress + ' through proxy ' + PROXY_INFO.address);\n                reject();\n            }\n        });\n        request.once('error', (err) => {\n            request.removeAllListeners();\n            trace('Failed to connect to proxy ' + PROXY_INFO.address);\n            reject();\n        });\n    });\n}\nexports.getProxiedConnection = getProxiedConnection;\n//# sourceMappingURL=http_proxy.js.map"]},"metadata":{},"sourceType":"script"}